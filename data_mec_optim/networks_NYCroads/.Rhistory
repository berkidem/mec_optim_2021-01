rm(list=ls())
install.packages("slam")
## Gurobi test
library(gurobi)
model <- list()
model$obj <- c(1, 1, 2)
model$modelsense <- "max"
model$rhs <- c(4, 1)
model$sense <- c("<", ">")
model$vtype <- "B"
model$A <- matrix(c(1, 2, 3, 1, 1, 0), nrow = 2, ncol = 3, byrow = TRUE)
result <- gurobi(model, list())
## Other packages
install.packages(c("nloptr", "nleqslv", "microbenchmark", "Rglpk", "magick", "igraph", "tidyverse", "rgdal", "rdist"))
install.packages("devtools")
install.packages("tictoc")
## Other packages
install.packages(c("nloptr", "Rmosek", "nleqslv", "microbenchmark", "Rglpk", "magick", "igraph", "tidyverse", "rgdal", "rdist", "tictoc"))
Rmosek::mosek_attachbuilder
Rmosek::mosek_attachbuilder()
mosek_attachbuilder(what_mosek_bindir)
Rmosek::mosek_attachbuilder(what_mosek_bindir)
rm(list=ls())
library(Matrix)
library(gurobi)
library(tictoc)
library(Rmosek)
library(Rglpk)
# setting up the data
thepath = paste0(getwd(),"/../data_mec_optim/lp_stigler-diet")
filename = "/StiglerData1939.txt"
thedata = as.matrix(read.csv(paste0(thepath, filename), sep = "\t", header = T))
nbCommodities = length(which(thedata[, 1] != "")) - 1
names = thedata[1:nbCommodities, 1]
themat = matrix(as.numeric(thedata[, 3:13]), ncol = 11)
themat[is.na(themat)] = 0
# calling Gurobi
N = t(themat[1:nbCommodities, 3:11])
d = themat[(nbCommodities + 1), 3:11]
c = rep(1, nbCommodities)
result = gurobi(list(A = N, obj = c, modelsense = "min", rhs = d, sense = ">"), params = list(OutputFlag = 0))
q_yearly = result$x * 365  # convert into yearly cost
pi = result$pi
cost_daily = result$objval
# display optimal solution
print("*** optimal solution ***")
toKeep = which(q_yearly != 0)
foods = q_yearly[toKeep]
names(foods) = names[toKeep]
print(foods)
print(paste0("Total cost (optimal)= ", sum(q_yearly * c)))
print("**************************")
# compare with Stigler's solution
print("*** Stigler's solution ***")
toKeepStigler = c(1, 15, 46, 52, 69)
foods_stigler = c(13.33, 3.84, 4.11, 1.85, 16.8)
names(foods_stigler) = names[toKeepStigler]
print(foods_stigler)
print(paste0("Total cost (Stigler)= ", sum(foods_stigler * c[toKeepStigler])))
print("**************************")
print("*** Optimal solution using Mosek ***")
mosekProblem = list(sense = "min", c= c, A=N, bc = rbind(d,Inf), bx = rbind(rep(0,nbCommodities),Inf) )
resMosek = mosek(mosekProblem , opts = list(verbose=1))
print(365*sum(resMosek$sol$itr$xx*c) )
# alternatively, use glpk
print("*** Optimal solution using Rglpk ***")
resGlpk = Rglpk_solve_LP(obj = c, mat = N, dir = rep(">", length(d)), rhs = d, bounds = NULL, max = FALSE, control = list())
print(resGlpk$optimum * 365)
library('gurobi')
require('Matrix')
require('igraph')
plotCurrentNetwork = function (network, curNode, nbNodes)
{sizeNodes= rep(1,nbNodes)
sizeNodes[originNode]=4
sizeNodes[destinationNode]=4
sizeNodes[curNode]=4
labelNodes = rep(NA,nbNodes)
labelNodes[originNode]=namesNodes[originNode]
labelNodes[destinationNode]=namesNodes[destinationNode]
labelNodes[curNode]=namesNodes[curNode]
plot.igraph(network,vertex.label=labelNodes, vertex.label.cex=1,vertex.size=sizeNodes, edge.arrow.size=0, layout = geoCoordinates)
}
originNode <- 84 #saint-germain des pres
destinationNode<- 116 #trocadero
thePath = paste0(getwd(),"/../data_mec_optim/networks_subway/NYC")
arcs = as.matrix(read.csv(paste0(thePath,"/arcs.csv"),sep=",", header=TRUE)) # loads the data
nodes = as.matrix(read.csv(paste0(thePath,"/nodes.csv"),sep=",", header=TRUE)) # loads the data
class(arcs) <- "numeric"
namesNodes=nodes[,1]
routeNodes = nodes[,7]
incomingFlow = nodes[,2]
class(incomingFlow)="numeric"
incomingFlow = incomingFlow / sum(incomingFlow)
originNode <- 452 #Union Sq
destinationNode<- 471  #59 St
speed=2
geoCoordinates = nodes[,3:4]
class(geoCoordinates)="numeric"
nbNodes = max(arcs[,1])
nbArcs = dim(arcs)[1]
n = rep(0,nbNodes) # construct vector of exiting flow
n[c(originNode,destinationNode)]=c(-1,1)
# construct node-incidence matrix:
Nabla =  sparseMatrix(i=1:nbArcs,j=arcs[,1],dims=c(nbArcs,nbNodes),x=-1) + sparseMatrix(i=1:nbArcs,j=arcs[,2],dims=c(nbArcs,nbNodes),x=1)
Phi <- -arcs[,4] # construct (minus) distance matrix
size(Nabla)
dim(Nabla)
Phi
arcs[,4]
arcs
# solve LP via Gurobi
result = gurobi ( list(A=t(Nabla),obj=Phi,modelsense='max',rhs=n,sense='=',start=matrix(0,nbArcs,1)), params=NULL)
t(Nabla)
Phi
# solve LP via Gurobi
result = gurobi ( list(A=t(Nabla),obj=Phi,modelsense='max',rhs=n,sense='=',start=matrix(0,nbArcs,1)), params=NULL)
phi
Phi
arcs
View(arcs)
arcs
View(nodes)
n
t(Nabla)
# solve LP via Gurobi
result = gurobi ( list(A=t(Nabla),obj=Phi,modelsense='max',rhs=n,sense='=',start=matrix(0,nbArcs,1)), params=NULL)
pi = result$x
distance = -result$objval
pi
distance
pi
sum(pi)
eqpath = which(pi>0)
leavingi = which(Nabla[,i]==-1)
i = originNode
leavingi = which(Nabla[,i]==-1)
library('gurobi')
library('Matrix')
thePath = paste0(getwd(),"/../data_mec_optim/networks_sovietplanning")
#data = read.csv(paste0(thePath,"/distances.csv"),sep=",", header=TRUE)
data = as.matrix(read.csv(paste0(thePath,"/distances.csv"),sep=",", header=TRUE)) # loads the data
nsources = 68
ndests = 10
dists = matrix(as.numeric(data[1:68,2:11]),68,10)
p = matrix(as.numeric(data[1:68,12]))
q = matrix(as.numeric(data[69,2:11]))
nonzeros = which(! is.na(dists))
nbNodes = nsources+ndests
nbArcs = length(nonzeros)
rows = (nonzeros-1) %% nsources + 1
cols = (nonzeros-1) %/% nsources + 1
costs = dists[nonzeros]
arcs = cbind(rows,cols+nsources,costs)
n = c(-p,q)
nameNodes = c(data[1:nsources] ,dimnames(data)[[2]][2:11])
# construct node-incidence matrix:
Nabla =  sparseMatrix(i=1:nbArcs,j=arcs[,1],dims=c(nbArcs,nbNodes),x=-1) + sparseMatrix(i=1:nbArcs,j=arcs[,2],dims=c(nbArcs,nbNodes),x=1)
# solve LP via Gurobi
result = gurobi ( list(A=t(Nabla),obj=costs,modelsense='min',rhs=n,sense='=',start=matrix(0,nbArcs,1)), params=NULL)
pi = result$x
distance = result$objval
print(distance)
library('gurobi')
require('Matrix')
require('igraph')
plotCurrentNetwork = function (network, curNode, nbNodes)
{sizeNodes= rep(1,nbNodes)
sizeNodes[originNode]=4
sizeNodes[destinationNode]=4
sizeNodes[curNode]=4
labelNodes = rep(NA,nbNodes)
labelNodes[originNode]=namesNodes[originNode]
labelNodes[destinationNode]=namesNodes[destinationNode]
labelNodes[curNode]=namesNodes[curNode]
plot.igraph(network,vertex.label=labelNodes, vertex.label.cex=1,vertex.size=sizeNodes, edge.arrow.size=0, layout = geoCoordinates)
}
originNode <- 84 #saint-germain des pres
destinationNode<- 116 #trocadero
thePath = paste0(getwd(),"/../data_mec_optim/networks_subway/NYC")
arcs = as.matrix(read.csv(paste0(thePath,"/arcs.csv"),sep=",", header=TRUE)) # loads the data
nodes = as.matrix(read.csv(paste0(thePath,"/nodes.csv"),sep=",", header=TRUE)) # loads the data
class(arcs) <- "numeric"
namesNodes=nodes[,1]
routeNodes = nodes[,7]
incomingFlow = nodes[,2]
class(incomingFlow)="numeric"
incomingFlow = incomingFlow / sum(incomingFlow)
originNode <- 452 #Union Sq
destinationNode<- 471  #59 St
speed=2
geoCoordinates = nodes[,3:4]
class(geoCoordinates)="numeric"
nbNodes = max(arcs[,1])
nbArcs = dim(arcs)[1]
n = rep(0,nbNodes) # construct vector of exiting flow
n[c(originNode,destinationNode)]=c(-1,1)
# construct node-incidence matrix:
Nabla =  sparseMatrix(i=1:nbArcs,j=arcs[,1],dims=c(nbArcs,nbNodes),x=-1) + sparseMatrix(i=1:nbArcs,j=arcs[,2],dims=c(nbArcs,nbNodes),x=1)
Phi <- -arcs[,4] # construct (minus) distance matrix
# solve LP via Gurobi
result = gurobi ( list(A=t(Nabla),obj=Phi,modelsense='max',rhs=n,sense='=',start=matrix(0,nbArcs,1)), params=NULL)
pi = result$x
distance = -result$objval
newyork=graph_from_edgelist(arcs[,1:2])
# deduce minimal distance path:
cont = TRUE
i = originNode
writeLines(paste0(namesNodes[i]," (#", i,")"))
eqpath = which(pi>0)
rank = 0
while(cont)
{
plotCurrentNetwork(newyork,i, nbNodes)
Sys.sleep(1/speed)
rank = rank+1
leavingi = which(Nabla[,i]==-1)
a = intersect(eqpath,leavingi)[1]
j = which(Nabla[a,]==1)[1]
writeLines(paste0(rank,": ", namesNodes[j], " ",routeNodes[j], " (#", j,")"))
i = j
if(j==destinationNode) {cont<-FALSE}
}
plotCurrentNetwork(newyork,destinationNode, nbNodes)
##################################### USING SPR
# to install SPR:
# require(devtools)
# install_github("TraME-Project/Shortest-Path-R")
#
library(SPR)
# run solver
sol <- dijkstra(nbNodes,originNode,arcs,destinationNode)
sp <- sol$path_list
# print
for (kk in 1) {
cat("Minimum distance from ", namesNodes[originNode], " to ", namesNodes[destinationNode],":\n",sep="")
cat(sol$min_dist,"\n\n")
cat("Path:\n",sep="")
for (i in 1:length(sp)) {
cat(i-1,": ", namesNodes[sp[i]]," (#",sp[i],")\n",sep="")
}
}
# Shortest path problem in the NYC road subway
#
# Reference:
# Charpentier, A., Galichon, A., Vernet, L. (2017).
# "Equilibrium for spatial allocation problems on networks"
#
# This code was written by Lucas Vernet
#
#
#
# to get coordinates associated with an address:
# https://www.gps-coordinates.net/
rm(list = ls())
library("Matrix")
library("gurobi")
library("rgdal")
library("rdist")
startlat = 40.70102
startlong = -73.90414
finishlat = 40.7290094
finishlong = -73.9952367
setwd(paste0(getwd(),"/../data_mec_optim/networks_NYCroads/"))
load("DataNYC.RData")
# Function shortest path
shortestPath = function(arcs, nodes, originNode, destinationNode) {
nbNodes = dim(nodes)[1]
nbArcs = dim(arcs)[1]
n = rep(0, nbNodes)
n[c(originNode, destinationNode)] = c(-1, 1)
Nabla = sparseMatrix(i = 1:nbArcs, j = arcs[, 1], dims = c(nbArcs, nbNodes), x = -1) + sparseMatrix(i = 1:nbArcs, j = arcs[,
2], dims = c(nbArcs, nbNodes), x = 1)
Phi <- -arcs[, 3]
result = gurobi(list(A = t(Nabla), obj = Phi, modelsense = "max", rhs = n, sense = "=", start = matrix(0, nbArcs, 1)),
params = NULL)
pi = result$x
distance = -result$objval
cont = TRUE
i = originNode
eqpath = which(pi > 0)
rank = 0
nodespath = c(0)
nodespath[rank + 1] = i
while (cont) {
rank = rank + 1
leavingi = which(Nabla[, i] == -1)
a = intersect(eqpath, leavingi)[1]
j = which(Nabla[a, ] == 1)[1]
i = j
nodespath[rank + 1] = i
if (j == destinationNode) {
cont <- FALSE
}
}
return(nodespath)
plot(shpNYC)
points(nodes[nodespath, ], col = "red")
}
# Excecute the function
StartGPS = matrix(c(startlong, startlat), ncol = 2)
FinishGPS = matrix(c(finishlong, finishlat), ncol = 2)
StartNAD83 = project(StartGPS, "+proj=lcc +lat_1=40.66666666666666 +lat_2=41.03333333333333 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000 +y_0=0 +datum=NAD83 +units=us-ft +no_defs")
FinishNAD83 = project(FinishGPS, "+proj=lcc +lat_1=40.66666666666666 +lat_2=41.03333333333333 +lat_0=40.16666666666666 +lon_0=-74 +x_0=300000 +y_0=0 +datum=NAD83 +units=us-ft +no_defs")
StartNode = which.min(cdist(StartNAD83, nodes, metric = "euclidean"))
FinishNode = which.min(cdist(FinishNAD83, nodes, metric = "euclidean"))
nodespath = shortestPath(arcs, nodes, StartNode, FinishNode)
# Plot the result
plot(shpNYC)
points(nodes[nodespath, ], col = "red")
rm(list=ls())
library('Matrix')
library('gurobi')
nbX = 10 #30
nbT = 40 #40
nbY = 2 # choice set: 1=run as usual; 2=overhaul
IdX = sparseMatrix(1:nbX,1:nbX)
LX=sparseMatrix(c(nbX,1:(nbX-1)),1:nbX)
RX=sparseMatrix(1:nbX,rep(1,nbX),dims=c(nbX,nbX))
P=kronecker(c(1,0),0.75*IdX+0.25*LX)+kronecker(c(0,1),RX)
IdT = sparseMatrix(1:nbT,1:nbT)
NT = sparseMatrix(1:(nbT-1),2:nbT,dims = c(nbT,nbT))
A = kronecker(kronecker(IdT,matrix(1,nbY,1)),IdX ) - kronecker(NT,P)
overhaulCost = 8E3
maintCost = function(x)(x*5E2)
beta = 0.9
n1_x = rep(1,nbX)
b_xt = c(n1_x,rep(0,nbX*(nbT-1)))
u_xy = c(-maintCost(1:(nbX-1)),rep(-overhaulCost,nbX+1))
u_xyt = c(kronecker(beta^(1:nbT),u_xy))
b_xt
b_xt
dim(b_xt)
b_xt = c(n1_x,rep(0,nbX*(nbT-1)))
b_xt
u_xyt
A
dim(A)
u_xyt
result   = gurobi ( list(A=A,obj=c(b_xt),modelsense="min",rhs=u_xyt,sense=">",lb=-Inf), params=list(OutputFlag=0) )
result
str(result)
result   = gurobi ( list(A=A,obj=c(b_xt),modelsense="min",rhs=u_xyt,sense=">",lb=-Inf))
b_xt
result   = gurobi ( list(A=A,obj=c(b_xt),modelsense="min",rhs=u_xyt,sense=">=",lb=-Inf))
c(b_xt)
apply(X = array(u_xyt,dim=c(nbX,nbY,nbT))[,,nbT],FUN = max,MARGIN = 1)
?apply
u_xyt
u_xy
nbY
contVals
rm(list=ls())
library('Matrix')
library('gurobi')
nbX = 10 #30
nbT = 40 #40
nbY = 2 # choice set: 1=run as usual; 2=overhaul
IdX = sparseMatrix(1:nbX,1:nbX)
LX=sparseMatrix(c(nbX,1:(nbX-1)),1:nbX)
RX=sparseMatrix(1:nbX,rep(1,nbX),dims=c(nbX,nbX))
P=kronecker(c(1,0),0.75*IdX+0.25*LX)+kronecker(c(0,1),RX)
IdT = sparseMatrix(1:nbT,1:nbT)
NT = sparseMatrix(1:(nbT-1),2:nbT,dims = c(nbT,nbT))
A = kronecker(kronecker(IdT,matrix(1,nbY,1)),IdX ) - kronecker(NT,P)
overhaulCost = 8E3
maintCost = function(x)(x*5E2)
beta = 0.9
n1_x = rep(1,nbX)
b_xt = c(n1_x,rep(0,nbX*(nbT-1)))
u_xy = c(-maintCost(1:(nbX-1)),rep(-overhaulCost,nbX+1))
u_xyt = c(kronecker(beta^(1:nbT),u_xy))
result   = gurobi ( list(A=A,obj=c(b_xt),modelsense="min",rhs=u_xyt,sense=">=",lb=-Inf))
# Backward induction
U_x_t = matrix(0,nbX,nbT)
contVals = apply(X = array(u_xyt,dim=c(nbX,nbY,nbT))[,,nbT],FUN = max,MARGIN = 1)
U_x_t[,nbT] = contVals
for (t in (nbT-1):1)
{
myopic = array(u_xyt,dim=c(nbX,nbY,nbT))[,,t]
Econtvals = matrix(P %*% contVals,nrow=nbX)
contVals = apply(X = myopic + Econtvals ,FUN = max,MARGIN = 1)
U_x_t[,t] = contVals
}
U_x_t_gurobi = array(result$x,dim=c(nbX,nbT))
print(U_x_t_gurobi[,1])
print(U_x_t[,1])
contValues
contVals
array(u_xyt,dim=c(nbX,nbY,nbT))[,,nbT]
apply(X = array(u_xyt,dim=c(nbX,nbY,nbT))[,,nbT],FUN = max,MARGIN = 1)
P %*% contVals
t = nbT - 1
myopic = array(u_xyt,dim=c(nbX,nbY,nbT))[,,t]
Econtvals = matrix(P %*% contVals,nrow=nbX)
Econtvals
P
dim(P)
contVals
U_x_t = matrix(0,nbX,nbT)
contVals = apply(X = array(u_xyt,dim=c(nbX,nbY,nbT))[,,nbT],FUN = max,MARGIN = 1)
U_x_t[,nbT] = contVals
contVals
myopic = array(u_xyt,dim=c(nbX,nbY,nbT))[,,t]
Econtvals = matrix(P %*% contVals,nrow=nbX)
Econtvals
myopic
Econtvals
contVals = apply(X = myopic + Econtvals ,FUN = max,MARGIN = 1)
contVals
U_x_t = matrix(0,nbX,nbT)
contVals = apply(X = array(u_xyt,dim=c(nbX,nbY,nbT))[,,nbT],FUN = max,MARGIN = 1)
U_x_t[,nbT] = contVals
for (t in (nbT-1):1)
{
myopic = array(u_xyt,dim=c(nbX,nbY,nbT))[,,t]
Econtvals = matrix(P %*% contVals,nrow=nbX)
contVals = apply(X = myopic + Econtvals ,FUN = max,MARGIN = 1)
U_x_t[,t] = contVals
}
U_x_t_gurobi = array(result$x,dim=c(nbX,nbT))
print(U_x_t_gurobi[,1])
print(U_x_t[,1])
A
dim(A)
#################################################
##########  (c) by Alfred Galichon     ##########
#################################################
rm(list=ls())
require('Matrix')
require('gurobi')
thepath = paste0(getwd(),"/../data_mec_optim/marriage_personality-traits")
#thepath = "C:/Users/Alfred/Dropbox/Collaborations/__Teaching/matheconcode/_applications/04-appli-optassign"
#load('personalityMarriageData.RData')
data = as.matrix(read.csv(paste0(thepath,"/affinitymatrix.csv"),sep=",", header=TRUE)) # loads the data
nbcar = 10
A = matrix(as.numeric(data[1:nbcar,2:(nbcar+1)]),nbcar,nbcar)
data = as.matrix(read.csv(paste0(thepath,"/Xvals.csv"),sep=",", header=TRUE)) # loads the data
Xvals = matrix(as.numeric(data[,1:nbcar]),ncol=nbcar)
data = as.matrix(read.csv(paste0(thepath,"/Yvals.csv"),sep=",", header=TRUE)) # loads the data
Yvals = matrix(as.numeric(data[,1:nbcar]),ncol=nbcar)
sdX = apply(Xvals,2,sd)
sdY = apply(Yvals,2,sd)
mX = apply(Xvals,2,mean)
mY = apply(Yvals,2,mean)
Xvals = t( (t(Xvals)-mX) / sdX)
Yvals = t( (t(Yvals)-mY) / sdY)
nobs = dim(Xvals)[1]
Phi = Xvals %*% A %*% t(Yvals)
p = rep(1/nobs,nobs)
q = rep(1/nobs,nobs)
N = dim(Phi)[1]
M = dim(Phi)[2]
c = c(Phi)
A1 = kronecker(matrix(1,1,M),sparseMatrix(1:N,1:N))
A2 = kronecker(sparseMatrix(1:M,1:M),matrix(1,1,N))
A = rbind2(A1,A2)
d = c(p,q)
result   = gurobi ( list(A=A,obj=c,modelsense="max",rhs=d,sense="="), params=list(OutputFlag=0) )
if (result$status=="OPTIMAL") {
pi = matrix(result$x,nrow=N)
u = result$pi[1:N]
v = result$pi[(N+1):(N+M)]
val = result$objval
} else {stop("optimization problem with Gurobi.") }
print(paste0("Value of the problem (Gurobi) =",val))
print(u[1:10])
print(v[1:10])
thePath = paste0(getwd(),"/../data_mec_optim/marriage_personality-traits")
data = as.matrix(read.csv(paste0(thepath,"/affinitymatrix.csv"),sep=",", header=TRUE)) # loads the data
thepath = paste0(getwd(),"/../data_mec_optim/marriage_personality-traits")
data = as.matrix(read.csv(paste0(thepath,"/affinitymatrix.csv"),sep=",", header=TRUE)) # loads the data
pi
